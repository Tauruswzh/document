基础


### 1、Jdk和Jre&虚拟机&跨平台
源文件是什么? 
是咱们程序员所写的以.java结尾的文件

Jdk ：Java的开发环境，是将.java结尾的编译成虚拟机能识别的.class文件：javac编译
Jre： Java的运行环境，包含着Java运行所需要类库：Scanner ArrayList
虚拟机： java代码运行的环境，只能识别.class 文件
Jdk > Jre >虚拟机

跨平台性：Java代码一次编译处处运行 
Java代码是跨平台的，虚拟机不是跨平台的，不同操作系统有不同的虚拟机


### 2、Java中的注释
单行注释： 	// 内容       可以单种嵌套
多行注释   	/*  内容 */   不能单种嵌套
文档注释   	/** 内容  */ 
注：注释之间可以嵌套使用


### 3、标识符
作用：自定义的内容(类，接口，变量，方法)的名称 

规则： 
	1. 数字0-9
	2. 英文大小写 
	3. _ 或$ 

注意：
	1.不能以数字开头
	2.不能使用关键字
	3.组成之间不能有空格
	4.区分大小写

命名的规范：见名知意 
        驼峰命名 
        大驼峰命名 :所有单词的首字母大写 (类和接口)
        小驼峰命名 :第一个单词的首字母小写,其余首字母大写 (变量和方法）

注：	常量命名:每个字母都大写,多个单词也是大写，单词间用下划线隔开
	包名：全部小写


### 4、进制（了解）
码表：现实生活中的文字和二进制之间的一个对应（映射）关系
编码：将对应的文字转换为二进制

进制转换：
	1.十进制转任意进制：除基倒取余
	2.任意进制转十进制：系数*基数的权次幂相加
注：基数：进制位

原反补：
	原码：二进制表示法 （正数：最高位0 负数：最高位1）
	反码：正数的反码不变，负数的反码最高位不变其余取反
	补码：正数的补码不变，负数的补码在反码基础上加1
注：补码是计算机真正的存储形式，也是计算形式


### 5、计算机存储单元
1:	最小的信息单元：	bit(位)
	最小的存储单元:	byte(字节)	

2: 	常用储存单位
	1B（字节） = 8bit
	1KB = 1024B 1MB = 1024KB


### 6、Java中数据类型四类八种
数据类型四类八种
	四类		   	八种			        字节数		
	整型		   	byte		   		1	    -128～127
				short		 	    2	    -32768-32767	
				int			 	    4	    (JAVA默认)（-2^31~2^31-1）
				long		 		8		  
	浮点型	  	float		   		4	    【单精度】
				double		 	    8	    (JAVA默认)【双精度】
	字符型	  	char		   		2 	    以''包裹起来的，里边只能有1个内容，如(‘a’，’A’，’0’，’家’)，0-65536（无符号的数据类型）
	布尔型	  	boolean 	   		1 	    只有两个值true与false
		
[取值范围：byte < short < int < long < float < double ]

注：java中默认内置的是UniCode码表：一个汉字对应2个字节，而正好char符合。


### 7、常量和数据类型
a: Java中默认整数类型是 int类型
b: Java中默认浮点类型是 double类型
c: 定义长整形数据（long）如果值超过int取值范围后面要+"L"
d: 定义float类型的数据后面要+"f" 否则默认是double


### 8、数据类型转换
8.1. 自动转换（隐式转换）
	 自动类型转换 (小转大)
	 表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换
	 格式：范围大的数据类型 变量 = 范围小的数据类型值；
	 如：    double d = 1000; d=1000.0
		
8.2. 强制转换（显式转换）
	强制类型转换（大转小）
	表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换
	格式：范围小的数据类型  变量 = (范围小的数据类型) 范围大的数据类型值;
	如：	int  i = (int)6.718;   //i的值为6

注： 
1.任何数据类型和大的数据类型进行四则 运算 时，都将自动提升为大的数据类型。（byte+char+int+double--->double）
2.byte short char在进行 运算 时都会默认将数据类型提升为int类型 (char+char=int)
3.常量优化机制：byte bt=3+4; == byte bt=7;  	//(必须右边都是常量)
4.仅针对于int类型赋值给其他小类型时，编译器会自动判断该数值是否是在此小类型的取值范围内，如果在此范围则自动将int类型转换为改小类型：byte b=10

注：
思考： 
byte a=10;
char b=a;  	[byte类型的取值范围包含了负数，char只有单个字符，所以会数据溢出]


### 9、算术运算符
A: 常见操作
		运算符	运算规则			范例				结果
		+		正号				+3			  	3
		+		加				2+3			   	5
		+		连接字符串		“中”+“国”		“中国”
		-		负号	    		int a=3;-a		-3
		-		减				3-1			   	2
		*		乘				2*3			   	6
		/		除				5/2			   	2
		%		取模				5/2			   	1
		++		自增				int a=1;a++/++a	2
		--		自减				int b=3;a--/--a	2

B: 注意事项	 [+的作用：求和，连接]
		a: 任何类型只要和字符串 "+" 则所有的数据都变成了字符串【（“5+5=”+5+5）==5+5=55】 【（3+4+“acv”+3+5）==7acv35】
		b: 除法“/”当两边为整数（int）时，取整数部分，舍余数。当其中一边为浮点型时，则结果为浮点型。 
		c: “%”为整除取余符号，小数取余没有意义。
		d: 整数做被除数，0不能做除数，否则报错。
		e: 小数做被除数，整除0结果为Infinity，对0取模结果为NaN

C: 算数运算符++、--的使用
		a: ++，--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1；
		b: ++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。
		注：参与运算：谁在前就谁先参与运算，但是最终，原有值都自增、自减1


### 10、赋值运算符
A: 赋值运算符的使用
		运算符	运算规则		范例				    结果
		=		赋值			int a=2			    2    	//(将右边的值赋值给左边的变量)
		+=		加后赋值		int a=2，a+=2		4 	    //（a=a+2）
		-=		减后赋值		int a=2，a-=2		0 	    //（a=a-2）
		*=		乘后赋值		int a=2，a*=2		4
		/=		整除后赋值	int a=2，a/=2		1
		%=		取模后赋值	int a=2，a%=2	    0

+=, -=, *=, /=, %= ++ -- [会将结果自动强转成等号左边的数据类型]
byte b=1;
b+=1 == b=(byte)(b+1)
b++ ==（byte）（b = b + 1）;
注意：赋值运算符左边必须是变量
	
	
### 11、比较运算符
A:比较运算符的使用
		运算符	运算规则		范例		结果
		==		相等于		4==3	False
		!=		不等于		4!=3	True
		<		小于			4<3	    False
		>		大于			4>3	    True
		<=		小于等于		4<=3	False
		>=		大于等于		4>=3	True
		 

### 12、逻辑运算符
A: 逻辑运算符的使用
		运算符	运算规则		范例				结果			规则
		&		与			false&true		False  		(有false则false)
		|		或			false|true		rue   		(有true则true）
		^		异或			true^flase		True   		(相同为false不同为true)
		!		非			!true			Flase
		&&		短路与		false&&true		False 		(左边是false，右边不执行------->结果为false)
		||		短路或		false||true		True  		(左边是true，右边半不执行------->结果为true)


注：运算符优先级：算术>比较>逻辑


### 13、三元运算符
格式: (条件表达式)? 为true的结果 : 为false的结果


### 14、循环语句
14.1. while循环
		while循环格式
			while(条件){    //boolean类型 //条件是true,就循环执行循环体，是false时,循环就结束
				循环体
				//计数器
		}
		示例：
			int i = 1;
			while( i < 5 ){
				System.out.println(i);
				i++;
			}

14.2. for循环
		for循环格式
			 for(初始化变量 ; 条件 ; 增量){  
				 循环体;
		}
		初始化变量: 定义变量,作用是用来控制循环的次数
		条件: 当条件是true,执行循环体,条件是false,结束循环
		增量: 变量自增情况 
		示例：
			for(int i = 0 ; i < 11 ; i++){
				System.out.println(i);
			}

14.3. for循环的执行流程
		for（1 ; 2 ; 3）{
			4
		} // 1 -> 2 -> 4 -> 3 -> 2 -> 4 -> 3...	
		第一步，执行1
		第二步，执行2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步
		第三步，执行4
		第四步，执行3，然后重复执行第2步
		第五步，退出循环	

14.4. do_while循环
		do_while循环格式
		do{
			 循环体;     //先执行一次,再判断条件
		 }while(条件);
		*执行顺序：
			先执行一次循环体，然后再判断条件，
			如果条件为true，继续执行循环体，
			如果条件为false，循环结束。

14.5. 死循环
		A: 概述
			* 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环
		B: 死循环格式
			* while(true){…}
			* for(;;){…}


### 15、switch语句(选择语句)
15.1. 格式：
switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。
		      swtich(表达式){
				  case 常量 :
				    要执行的语句;
				  break;
					......
				  default:
				    要执行的语句;
				  break;
			  }
（表达式,和case后面的常量进行比较，相同,就执行哪个case后面的程序,遇到break,就跳出结束）
		
15.2. switch语句接受的数据类型【不接受dubbo类型】
		JDK1.0 - 1.4  	数据类型接受 byte short int char
		JDK1.5   		数据类型接受 byte short int char enum(枚举)
		JDK1.7   		数据类型接受 byte short int char enum(枚举), String	
	
15.3. case穿透
在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可（这是一种简写的方式）
（case 后语句结束没有break,则程序会一直向下执行，直到switch结束）

示例：
		switch (week) {
			case 1:
			case 2:
				System.out.println("今天是工作日");
				break;



### 16、跳转语句 
break语句		终止所在的循环
continue语句		跳过当次循环，继续进行下次循环



### 17、数组的定义
1、数据类型[] 数组名 = new 数据类型[元素个数或数组长度];
    int[] arr = new int[100];
    
2、类型[] 数组名 = new 类型[]{元素，元素，……};（不好）
    int[] arr = new int[]{1,2,3,4};
    
3、类型[] 数组名 = {元素，元素，元素，……};	 
    int[] arr = { 1, 2, 3, 4 };



### 18、java 值类型和引用类型
值类型：
整数类型(byte,short,long)
浮点类型(float,double)
布尔类型(boolean)
字符类型(char)

引用类型：
类、数组、接口

区别：
值传递：基本数据类型的赋值是值传递，当值类型变量a赋值给值类型变量b之后，再去改变a的值则b不会变化
引用传递：引用类型的赋值是引用传递，传递的是对象的引用地址
内存分配：值类型数据是直接存储在栈中，引用类型数据并不是直接存储在栈中，JVM会在堆中给数据分配内存空间，堆存储数据

注：如果对象中包含值类型数据，那么该值类型数据保存在堆中


变量: private String str=“xx”; 			
常量: Public static final String str=“xx”; 