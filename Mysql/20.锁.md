锁

###1、乐观锁
数据库自定义 版本号字段

乐观锁不是数据库自带的，需要我们自己去实现。
乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，
在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

操作：
> 在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。
> 也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，
> 如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；
> 如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。


###2、悲观锁
分为：共享锁，排它锁

与乐观锁相对应的就是悲观锁了。
悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，

这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。
另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。


####2.1:共享锁	lock in share mode
所有事务共享读的权限, 共享锁又称读锁 read lock。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。[其他获得共享锁的事务只能读数据，不能修改数据]
当事务同时增加共享锁时候，事务的更新必须等待先执行的事务 commit 后才行，如果同时并发太大可能很容易造成死锁。

[共享锁使用的时候（查询、更新、删除）的时候是允许其他事务进行查询操作的]

由此：我们可以基本得出结论：lock in share mode 的特性是：
> 1:允许多个事务对同一个行进行加锁，因为他是共享锁。
> 2:在除自己外的其他事务持有锁时，update, delete操作会被阻塞。

示例:
```sql
控制台1:
begin;/begin work;/start transaction;  (三者选一就可以)
SELECT * from TABLE where id = 1  lock in share mode;		//查询结果集的数据都会加共享锁
未commit

控制台2:
同样设置共享锁
begin;/begin work;/start transaction;  (三者选一就可以)
SELECT * from TABLE where id = 1  lock in share mode;		//查询结果集的数据都会加共享锁
未commit
则: 能查询到数据

控制台2再操作:
update TABLE set name="www.souyunku.com" where id =1;
此时, 操作界面进入了卡顿状态, 过了超时间, 提示错误信息

控制台1:
commit;

控制台2:
update操作才成功

假如: 控制台1 未commit 同时操作:
update TABLE set name="www.souyunku.com" where id =1;
则会出现死锁
```

应用：
一个表是child表，一个是parent表，
假设child表的某一列child_id映射到parent表的c_child_id列

那么从业务角度讲，此时我直接insert一条child_id=100记录到child表是存在风险的，
因为刚insert的时候可能在parent表里删除了这条c_child_id=100的记录，那么业务数据就存在不一致的风险。

正确的方法是在插入时执行：
select * from parent where c_child_id=100 lock in share mode, 锁定了parent表的这条记录，
然后执行insert into child(child_id) values (100)就ok了。

[lock in share mode适用于两张表存在业务关系时的一致性要求，for update适用于操作同一张表时的一致性要求]


####2.2: 排它锁	for update
同步锁：只能自己操作：释放后其他事务才能操作, 排他锁 exclusive lock（也叫writer lock）又称写锁
排它锁是悲观锁的一种实现

若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。
这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁

读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁，
使用方式：在需要执行的语句后面加上for update就可以了

[InnoDB引擎默认: 修改数据语句:update,delete,insert都会自动给涉及到的数据加上排他锁,  select语句默认不会加任何锁类型]



###3、行锁
行锁又分共享锁和排他锁, 由字面意思理解，就是给[某一行加上锁]，也就是一条记录加上锁。

注意：[行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁]

共享锁：
结果集的数据都会加共享锁
SELECT * from TABLE where id = 1 lock in share mode;

排他锁：
select status from TABLE where id=1 for update;

主键相当于索引。执行加锁时，会将id这个索引为1的记录加上锁，那么这个锁就是行锁。



###4、表锁
使用行锁但是没有通过索引条件检索数据的表是锁定全表的

[innodb 存储引擎既支持行级锁，也支持表级锁，但默认情况下采用行级锁]

表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 web 应用；
而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。



###5、死锁
死锁的条件：
- 互斥访问
- 请求保持
- 循环等待
- 不可剥夺

所谓死锁：
是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去。
此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。[表级锁不会产生死锁] 所以解决死锁主要还是针对于最常用的InnoDB。

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。
那么对应的解决死锁问题的关键就是：
让不同的session加锁有次序。

![死锁](./image/死锁.tiff)

发生死锁后，innodb一般都能自动检测到，并是一个事务释放锁回退，另一个事务获得锁，继续完成事务。
但在涉及外部锁或表锁的情况下，innodb并不能完全自动检测到死锁，只需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。

需要说明的是：
这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，
会占用大量计算机资源，造成严重的性能问题，甚至拖垮数据库。

通常来说，死锁都是应用设计的问题，通过调整业务流程，数据库对象设计、事务大小、以及访问数据库的sql语句，绝大部分死锁都可以避免。



###6、Mysql
MySQL有三种锁的级别：页级、表级、行级。

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

算法：
- next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap
- Gap锁，不锁记录，仅仅记录前面的Gap
- Recordlock锁（锁数据，不锁Gap）
- 所以其实 Next-KeyLocks=Gap锁+ Recordlock锁